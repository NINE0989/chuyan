// Composite shader: concise on top of white (white underneath concise)
// Generated by merging `shaders/concise.glsl` and `shaders/white.glsl`.

#version 330 core

#ifdef GL_ES
precision mediump float;
#endif

#ifndef TEX
#ifdef GL_ES
#define TEX(s, uv) texture2D(s, uv)
#else
#define TEX(s, uv) texture(s, uv)
#endif
#endif

uniform vec3 iResolution;
uniform float iTime;
uniform sampler2D iChannel0;

out vec4 fragColor;

// --- Helpers from white.glsl -------------------------------------------------
vec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2
    vec3 t = 3.0 * x;
    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);
    vec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);
    vec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);
    return 0.5 * (
        b0 * pow(t, vec3(2.0)) +
        b1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + 
        b2 * pow(3.0-t,vec3(2.0))
    );
}

// --- Helpers from concise.glsl -----------------------------------------------
#define PI 3.14159265359
#define TWO_PI 6.28318530718

float random (vec2 st) {
    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);
}

float random_float(float seed, float minv, float maxv) {
    return floor(minv + random(vec2(seed)) * (maxv/minv));
}

vec2 rotate2D(vec2 _uv, float _angle){
    _uv =  mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle)) * _uv;
    return _uv;
}

float polygon(vec2 _uv, float size, float width, float sides) {
    // Angle and radius from the current pixel
    float a = atan(_uv.x,_uv.y)+PI;
    float r = TWO_PI/float(sides);

    // Shaping function that modulate the distance
    float d = cos(floor(.5+a/r)*r-a)*length(_uv);

    // ensure smoothstep has increasing edges
    return smoothstep(0.0, 0.005, abs(d-size)-width/2.0);
}

// five-point star mask: keep signature similar to polygon()
float star(vec2 _uv, float outerR, float width, float points) {
    // produce a sharp-pointed star using angular cosine lobes
    float innerR = outerR * 0.35;
    float a = atan(_uv.y, _uv.x);
    float r = length(_uv);
    float n = points;
    float lobes = cos(a * n);
    float sharp = pow(max(0.0, lobes), 40.0);
    float desired = mix(innerR, outerR, sharp);
    return smoothstep(0.0, 0.005, abs(r - desired) - width/2.0);
}

// audio texture width used for normalized lookup
const int AUDIO_BANDS = 512;

// --- mainImage implementations (renamed) ------------------------------------
void mainImageWhite( out vec4 outColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord.xy / iResolution.xy;

    float fVBars = 100.0;
    float fHSpacing = 1.00;
    float fHFreq = (uv.x * 3.14159265);
    float squarewave = sign(sin(fHFreq * fVBars) + 1.0 - fHSpacing);

    float x = floor(uv.x * fVBars) / fVBars;
    float fSample = TEX(iChannel0, vec2(abs(2.0 * x - 1.0), 0.25)).x;
    float fft = squarewave * fSample * 0.5;

    float fHBars = 100.0;
    float fVSpacing = 0.180;
    float fVFreq = (uv.y * 3.14159265);
    fVFreq = sign(sin(fVFreq * fHBars) + 1.0 - fVSpacing);

    vec2 centered = vec2(1.0) * uv - vec2(1.0);
    float t = iTime / 100.0;
    float polychrome = 1.0;
    vec3 spline_args = fract(vec3(polychrome * uv.x - t) + vec3(0.0, -1.0/3.0, -2.0/3.0));
    vec3 spline = B2_spline(spline_args);

    float f = abs(centered.y);
    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f * spline;
    vec3 flame_color = pow(base_color, vec3(3.0));

    float tt = 0.3 - uv.y;
    float df = sign(tt);
    df = (df + 1.0) / 0.5;
    vec3 col = flame_color * vec3(1.0 - step(fft, abs(0.3 - uv.y))) * vec3(fVFreq);
    col -= col * df * 0.180;

    // Convert color visualization to white intensity on black
    float intensity = length(col);
    intensity = pow(intensity, 0.9) * 1.8;
    intensity = clamp(intensity, 0.0, 1.0);

    outColor = vec4(vec3(intensity), 1.0);
}

void mainImageConcise( out vec4 outColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord / iResolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;

    // sample approximate bands using normalized texture coordinates
    float bass = 0.0;
    for (int i = 0; i < 10; ++i) {
        float uu = (float(i) + 0.5) / float(AUDIO_BANDS);
        bass += TEX(iChannel0, vec2(uu, 0.0)).x;
    }
    bass /= 10.0;

    float med = 0.0;
    for (int i = 0; i < 20; ++i) {
        float idx = 240.0 - float(i);
        float uu = (idx + 0.5) / float(AUDIO_BANDS);
        med += TEX(iChannel0, vec2(uu, 0.0)).x;
    }
    med /= 20.0;

    float high = 0.0;
    for (int i = 0; i < 20; ++i) {
        float idx = 500.0 - float(i);
        float uu = (idx + 0.5) / float(AUDIO_BANDS);
        high += TEX(iChannel0, vec2(uu, 0.0)).x;
    }
    high /= 20.0;

    float vol = (bass + med + high) / 3.0;
    const int CHECK_BANDS = 64;
    float lowSum = 0.0;
    float highSum = 0.0;
    for (int bi = 0; bi < CHECK_BANDS; ++bi) {
        float uuLow = (float(bi) + 0.5) / float(AUDIO_BANDS);
        float uuHigh = (float(AUDIO_BANDS - 1 - bi) + 0.5) / float(AUDIO_BANDS);
        lowSum += TEX(iChannel0, vec2(uuLow, 0.0)).x;
        highSum += TEX(iChannel0, vec2(uuHigh, 0.0)).x;
    }
    float lowAvg = lowSum / float(CHECK_BANDS);
    float highAvg = highSum / float(CHECK_BANDS);
    float balance = highAvg - lowAvg;

    float dirThreshold = 0.03;
    float dirSign = 0.0;
    if (balance > dirThreshold) dirSign = 1.0;
    else if (balance < -dirThreshold) dirSign = -1.0;

    float baseSpeed = 0.1;
    float audioRot = vol * abs(balance) * 6.0;
    float angle = iTime * baseSpeed + dirSign * audioRot;
    uv = rotate2D(uv, angle);

    float seed = 8.0;
    float size = clamp(0.6 * bass * 2.0 + 0.18, 0.0, 0.95);
    float width = 0.02 + 0.3 * vol;
    float rgbShift = 0.02 * vol;
    float colorR = star(uv - vec2(rgbShift, 0.0), size, width, 5.0);
    float colorG = star(uv, size, width, 5.0);
    float colorB = star(uv + vec2(rgbShift, 0.0), size, width, 5.0);
    vec3 shapeColor = vec3(colorR, colorG, colorB);

    // only draw the star; invert so subject is white (1.0) and background is black (0.0)
    outColor = vec4(1.0 - shapeColor, 1.0);
}

// --- composite main ---------------------------------------------------------
void main() {
    vec4 whiteCol = vec4(0.0);
    vec4 conciseCol = vec4(0.0);
    mainImageWhite(whiteCol, gl_FragCoord.xy);
    mainImageConcise(conciseCol, gl_FragCoord.xy);

    // Decide where concise should show. Use concise luminance as mask.
    float conciseMask = clamp(length(conciseCol.rgb), 0.0, 1.0);

    // If conciseMask is zero, show white (under), else show concise (top).
    vec3 finalRGB = mix(whiteCol.rgb, conciseCol.rgb, conciseMask);

    fragColor = vec4(finalRGB, 1.0);
}
